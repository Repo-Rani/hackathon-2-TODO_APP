---
id: 002
title: Create Phase 2 Spec
stage: spec
date_iso: 2026-01-11
surface: agent
model: Claude Sonnet 4.5
feature: full-stack-todo
branch: main
user: user
command: /sp.specify
labels:
  - spec
  - phase2
  - todo-app
  - fullstack
links:
  spec: specs/004-full-stack-todo-phase-2/spec.md
  ticket: null
  adr: null
  pr: null
files_yaml:
  - C:\Users\HP\Desktop\hackathon-2 - phase-1\specs\004-full-stack-todo-phase-2\spec.md
  - C:\Users\HP\Desktop\hackathon-2 - phase-1\specs\004-full-stack-todo-phase-2\checklists\requirements.md
tests_yaml:
  - "Created spec for Phase 2 Full-Stack Todo application"
  - "Created quality checklist for requirements"
prompt_text: "Phase 2: Full-Stack Todo Web Application - Complete Specification\nDocument Information\n\nSpec ID: SPEC-P2-COMPLETE-001\nVersion: 1.0.0\nCreated: January 11, 2026\nPhase: Phase II of Hackathon Evolution of Todo\nStatus: Ready for Implementation\n\n\nTable of Contents\n\nProject Overview\nConstitution & Principles\nTechnology Stack\nUser Stories & Requirements\nDatabase Design (SQLModel)\nAPI Specification\nAuthentication & Security\nFrontend Specification\nImplementation Plan\nTesting Strategy\nDeployment Guide\nQuality Gates\n\n\n1. Project Overview\n1.1 Purpose\nTransform Phase 1 console todo app into a modern, multi-user web application with:\n\nPersistent storage (Neon PostgreSQL)\nUser authentication (Better Auth + JWT)\nRESTful API (FastAPI)\nResponsive web UI (Next.js)\nSQLModel ORM (NOT SQLAlchemy directly)\n\n1.2 What's Changing from Phase 1?\nAspectPhase 1Phase 2StorageIn-memory Python dictNeon PostgreSQLInterfaceConsole (CLI)Web browserUsersSingle userMulti-user with authArchitectureMonolithic scriptFrontend + Backend APIData ModelSimple dictSQLModel classes\n1.3 Success Criteria\n✅ All 5 Basic Level features work as web app\n✅ Multi-user system with complete data isolation\n✅ Authentication secure (JWT tokens)\n✅ Data persists across server restarts\n✅ Responsive UI (mobile + desktop)\n✅ 100% Spec-Driven Development (no manual coding)\n\n2. Constitution & Principles\n2.1 Core Development Principles\nPrinciple #1: Spec-Driven Development (NON-NEGOTIABLE)\nRule: Every line of code MUST be generated by Claude Code from specifications.\nWorkflow:\nSpecify (WHAT) → Plan (HOW) → Tasks (STEPS) → Implement (CODE)\nEnforcement:\n\nWrite markdown specs first\nUse Spec-Kit Plus to manage specs\nClaude Code implements from tasks only\nNO manual coding except specs\n\nPrinciple #2: SQLModel for Database\nRule: Use SQLModel (NOT raw SQLAlchemy) for all database operations.\nWhy SQLModel:\n\nCombines SQLAlchemy Core + Pydantic\nType hints throughout\nSingle model for database + API\nCleaner syntax than raw SQLAlchemy\nCreated by same author as FastAPI\n\nExample:\npython# ✅ CORRECT (SQLModel)\nfrom sqlmodel import SQLModel, Field, Session\n\nclass Task(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str\n\n# ❌ WRONG (Raw SQLAlchemy)\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\nclass Task(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True)\nPrinciple #3: Separation of Concerns\nFrontend: Next.js (UI only, no business logic)\nBackend: FastAPI (Business logic, database, auth)\nDatabase: Neon PostgreSQL (Data persistence)\nPrinciple #4: Security First\n\nBetter Auth handles password hashing\nJWT tokens for API authorization\nUser isolation (can't access others' data)\nEnvironment variables for all secrets\nCORS properly configured\n\nPrinciple #5: Type Safety\n\nTypeScript strict mode (frontend)\nPython type hints everywhere (backend)\nSQLModel provides types for database\nPydantic validates API requests\n\n\n3. Technology Stack\n3.1 Complete Stack Overview\nLayerTechnologyVersionPurposeFrontendNext.js16+Web UI frameworkTypeScript5.xType-safe JavaScriptTailwind CSS3.xStylingBetter AuthLatestAuthenticationBackendFastAPILatestREST API frameworkPython3.13+Programming languageSQLModelLatestORM (NOT SQLAlchemy)UvicornLatestASGI serverDatabaseNeon PostgreSQL15+Serverless databaseDev ToolsClaude CodeLatestAI code generationSpec-Kit PlusLatestSpec managementUVLatestPython package manager\n3.2 Why SQLModel? (Detailed)\nTraditional SQLAlchemy Approach:\npython# Separate database model\nclass TaskDB(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True)\n    title = Column(String(200))\n\n# Separate Pydantic model for API\nclass TaskAPI(BaseModel):\n    id: int\n    title: str\n\n# Manual conversion needed\ndef db_to_api(task_db: TaskDB) -> TaskAPI:\n    return TaskAPI(id=task_db.id, title=task_db.title)\nSQLModel Approach (What We Use):\npython# Single model for BOTH database AND API\nfrom sqlmodel import SQLModel, Field\nclass Task(SQLModel, table=True):\n    id: Optional[int] = Field(default=None, primary_key=True)\n    title: str = Field(max_length=200)\n\n# Automatic conversion, type hints everywhere\ntask = Task(title=\"Buy groceries\")\nBenefits:\n✅ Single source of truth\n✅ Less code duplication\n✅ Type hints everywhere\n✅ Works with FastAPI automatically\n✅ Pydantic validation built-in\n\n4. User Stories & Requirements\n4.1 User Authentication\nUS-001: User Signup\nAs a new user\nI want to create an account\nSo that I can manage my personal todo list\nAcceptance Criteria:\n\nUser provides email and password\nEmail must be unique (database constraint)\nPassword minimum 8 characters\nPassword automatically hashed by Better Auth\nUser auto-logged in after signup\nJWT token generated and returned\nClear error messages for validation failures\n\nTechnical Implementation:\n\nBetter Auth /api/auth/signup endpoint\nSQLModel User table (managed by Better Auth)\nJWT token includes user_id claim\nFrontend stores token in httpOnly cookie\n\nUS-002: User Signin\nAs a returning user\nI want to log into my account\nSo that I can access my tasks\nAcceptance Criteria:\n\nUser provides email and password\nBetter Auth verifies password hash\nValid credentials return JWT token\nInvalid credentials return 401 with message\nToken valid for 7 days\nFrontend redirects to task list on success\n\nUS-003: Protected Routes\nAs a system\nI want to verify authentication on all API requests\nSo that only logged-in users access their data\nAcceptance Criteria:\n\nAll /api/{user_id}/tasks endpoints require JWT\nMissing token returns 401 Unauthorized\nInvalid/expired token returns 401\nJWT user_id must match URL user_id\nMismatch returns 403 Forbidden\n\n4.2 Task Management\nUS-004: Add Task\nAs a logged-in user\nI want to create a new task\nSo that I can track things to do\nAcceptance Criteria:\n\nTitle required (1-200 characters)\nDescription optional (max 1000 characters)\nTask saves with user_id from JWT\nReturns created task with generated ID\nSuccess message displays\nTask appears in list immediately\n\nSQLModel Implementation:\npythontask = Task(\n    user_id=user_id,\n    title=\"Buy groceries\",\n    description=\"Milk, eggs, bread\",\n    completed=False\n)\nsession.add(task)\nsession.commit()\nsession.refresh(task)\nUS-005: View Task List\nAs a logged-in user\nI want to see all my tasks\nSo that I know what needs doing\nAcceptance Criteria:\n\nShows only authenticated user's tasks\nSorted by created_at DESC (newest first)\nDisplays title, status, created date\nCompleted tasks visually distinct\nEmpty state when no tasks\nLoading spinner while fetching\n\nSQLModel Query:\npythonfrom sqlmodel import select\n\nstatement = select(Task).where(\n    Task.user_id == user_id\n).order_by(Task.created_at.desc())\n\ntasks = session.exec(statement).all()\nUS-006: Update Task\nAs a logged-in user\nI want to edit task details\nSo that I can correct mistakes\nAcceptance Criteria:\n\nCan update title and/or description\nSame validation as create\nMust own the task (403 if not)\nUpdates updated_at timestamp\nReturns updated task\nOptimistic UI update\n\nSQLModel Implementation:\npythonstatement = select(Task).where(\n    Task.id == task_id,\n    Task.user_id == user_id\n)\ntask = session.exec(statement).first()\n\nif not task:\n    raise HTTPException(404, \"Task not found\")\n\nif title:\n    task.title = title\nif description is not None:\n    task.description = description\n\ntask.updated_at = datetime.utcnow()\nsession.add(task)\nsession.commit()\nsession.refresh(task)\nUS-007: Delete Task\nAs a logged-in user\nI want to remove tasks\nSo that I can clean up my list\nAcceptance Criteria:\n\nConfirmation dialog before delete\nHard delete from database\nMust own task (403 if not)\nReturns 204 No Content on success\nTask removed from UI immediately\n\nSQLModel Implementation:\npythonstatement = select(Task).where(\n    Task.id == task_id,\n    Task.user_id == user_id\n)\ntask = session.exec(statement).first()\n\nif not task:\n    raise HTTPException(404, \"Task not found\")\n\nsession.delete(task)\nsession.commit()\nUS-008: Mark Task Complete\nAs a logged-in user\nI want to toggle completion status\nSo that I can track progress\nAcceptance Criteria:\n\nClick checkbox to toggle\nVisual change immediate\nUpdates database\nCan toggle back to incomplete\nUpdates updated_at timestamp\n\nSQLModel Implementation:\npythontask = session.exec(\n    select(Task).where(\n        Task.id == task_id,\n        Task.user_id == user_id\n    )\n).first()\n\nif not task:\n    raise HTTPException(404)\n\ntask.completed = not task.completed\ntask.updated_at = datetime.utcnow()\nsession.add(task)\nsession.commit()\n\n5. Database Design (SQLModel)\n5.1 Database Platform\n\nProvider: Neon (https://neon.tech)\nType: Serverless PostgreSQL 15+\nFree Tier: 500MB storage, 1 database\nConnection: Standard PostgreSQL protocol\n\nEnvironment Variable:\nbashDATABASE_URL=postgresql://user:pass@ep-xxx.region.aws.neon.tech/neondb?sslmode=require\n5.2 Entity Relationship Diagram\n┌─────────────────────┐\n│      users          │\n│  (Better Auth)      │\n├─────────────────────┤\n│ id (TEXT) PK        │\n│ email (TEXT) UNIQUE │\n│ namary_key=True)\n    email: str = Field(unique=True, index=True)\n    name: Optional[str] = None\n    email_verified: bool = Field(default=False)\n    created_at: datetime = Field(default_factory=datetime.utcnow)\n    updated_at: datetime = Field(default_factory=datetime.utcnow)\nTask Model (Primary Model)\npythonfrom sqlmodel import SQLModel, Field\nfrom datetime import datetime\nfrom typing import Optional\nclass Task(SQLModel, table=True):\n    \"\"\"\n    Task model for todo items.\n    Used for BOTH database table AND API responses.\n    \"\"\"\n    __tablename__ = \"tasks\"\n    \n    # Primary Key\n    id: Optional[int] = Field(\n        default=None,\n        primary_key=True,\n        description=\"Auto-incrementing task ID\"\n    )\n    \n    # Foreign Key to User\n    user_id: str = Field(\n        foreign_key=\"users.id\",\n        index=True,\n        description=\"Owner of this task\"\n    )\n    \n    # Task Data\n    title: str = Field(\n        min_length=1,\n        max_length=200,\n        description=\"Task title (required)\"\n    )\n    \n    description: Optional[str] = Field(\n        default=None,\n        max_length=1000,\n        description=\"Optional task description\"\n    )\n    \n    # Status\n    completed: bool = Field(\n        default=False,\n        description=\"Completion status\"\n    )\n    \n    # Timestamps\n    created_at: datetime = Field(\n        default_factory=datetime.utcnow,\n        description=\"Creation timestamp\"\n    )\n    \n    updated_at: datetime = Field(\n        default_factory=datetime.utcnow,\n        description=\"Last update timestamp\"\n    )\n    \n    class Config:\n        json_schema_extra = {\n            \"example\": {\n                \"title\": \"Buy groceries\",\n                \"description\": \"Milk, eggs, bread\",\n                \"completed\": False\n            }\n        }\n5.4 Pydantic Schemas (Request/Response)\nRequest Schemas\npythonfrom pydantic import BaseModel, Field, validator\nfrom typing import Optional\nclass TaskCreate(BaseModel):\n    \"\"\"Schema for POST /api/{user_id}/tasks\"\"\"\n    \n    title: str = Field(\n        ...,\n        min_length=1,\n        max_length=200,\n        example=\"Buy groceries\"\n    )\n    \n    description: Optional[str] = Field(\n        None,\n        max_length=1000,\n        example=\"Milk, eggs, bread\"\n    )\n    \n    @validator('title')\n    def title_not_empty(cls, v):\n        if not v or not v.strip():\n            raise ValueError('Title cannot be empty')\n        return v.strip()\n\nclass TaskUpdate(BaseModel):\n    \"\"\"Schema for PUT /api/{user_id}/tasks/{id}\"\"\"\n    \n    title: Optional[str] = Field(None, min_length=1, max_length=200)\n    description: Optional[str] = Field(None, max_length=1000)\n    \n    @validator('title')\n    def title_not_empty(cls, v):\n        if v is not None and not v.strip():\n            raise ValueError('Title cannot be empty')\n        return v.strip() if v else None\nResponse Schemas\npythonfrom datetime import datetime\nclass TaskResponse(BaseModel):\n    \"\"\"Schema for task API responses\"\"\"\n    \n    id: int\n    user_id: str\n    title: str\n    description: Optional[str]\n    completed: bool\n    created_at: datetime\n    updated_at: datetime\n    \n    class Config:\n        json_encoders = {\n            datetime: lambda v: v.isoformat()\n        }\n5.5 Database Connection (SQLModel)\npythonfrom sqlmodel import SQLModel, create_engine, Session\nimport os\n\n# Get connection string from environment\nDATABASE_URL = os.getenv(\"DATABASE_URL\")\n\n# Create SQLModel engine\nengine = create_engine(\n    DATABASE_URL,\n    echo=False,  # Set True to see SQL queries\n    pool_pre_ping=True,  # Verify connections\n    pool_size=5,\n    max_overflow=10\n)\n\n# Initialize tables\ndef init_db():\n    \"\"\"Create all tables defined with SQLModel\"\"\"\n    SQLModel.metadata.create_all(engine)\n\n# Dependency for FastAPI\ndef get_session():\n    \"\"\"Provide database session to endpoints\"\"\"\n    with Session(engine) as session:\n        yield session\n5.6 Database Migrations\nInitial Migration SQL\nsql-- migrations/001_initial.sql\n\n-- Users table (Better Auth manages)\nCREATE TABLE users (\n    id TEXT PRIMARY KEY,\n    email TEXT UNIQUE NOT NULL,\n    name TEXT,\n    email_verified BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Tasks table\nCREATE TABLE tasks (\n    id SERIAL PRIMARY KEY,\n    user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    title TEXT NOT NULL CHECK (length(title) BETWEEN 1 AND 200),\n    description TEXT CHECK (description IS NULL OR length(description) <= 1000),\n    completed BOOLEAN DEFAULT FALSE,\n    created_at TIMESTAMP DEFAULT NOW(),\n    updated_at TIMESTAMP DEFAULT NOW()\n);\n\n-- Indexes for performance\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_tasks_user_id ON tasks(user_id);\nCREATE INDEX idx_tasks_completed ON tasks(completed);\nCREATE INDEX idx_tasks_created_at ON tasks(created_at DESC);\nRun via Neon Console:\n\nLogin to neon.tech\nSelect database\nSQL Editor → Paste → Execute\n\n\n6. API Specification\n6.1 Base URL\n\nDevelopment: http://localhost:8000\nProduction: https://your-backend.railway.app (or similar)\n\n6.2 Authentication Header\nAll protected endpoints require:\nAuthorization: Bearer <jwt_token>\n6.3 Complete API Endpoints\nEndpoint Summary Table\nMethodEndpointAuthDescriptionPOST/api/auth/signupNoCreate accountPOST/api/auth/signinNoLoginGET/api/{user_id}/tasks✅List tasksPOST/api/{user_id}/tasks✅Create taskGET/api/{user_id}/tasks/{id}✅Get task detailsPUT/api/{user_id}/tasks/{id}✅Update taskDELETE/api/{user_id}/tasks/{id}✅Delete taskPATCH/api/{user_id}/tasks/{id}/complete✅Toggle complete\n6.4 Detailed Endpoint Specifications\nPOST /api/{user_id}/tasks (Create Task)\nRequest:\nhttpPOST /api/user_abc123/tasks\nAuthorization: Bearer eyJhbGc...\nContent-Type: application/json\n\n{\n  \"title\": \"Buy groceries\",\n  \"description\": \"Milk, eggs, bread\"\n}\nSuccess Response (201 Created):\njson{\n  \"id\": 5,\n  \"user_id\": \"user_abc123\",\n  \"title\": \"Buy groceries\",\n  \"description\": \"Milk, eggs, bread\",\n  \"completed\": false,\n  \"created_at\": \"2025-01-11T10:30:00Z\",\n  \"updated_at\": \"2025-01-11T10:30:00Z\"\n}\nError Responses:\njson// 400 Bad Request - Validation Error\n{\n  \"detail\": [\n    {\n      \"loc\": [\"body\", \"title\"],\n      \"msg\": \"ensure this value has at least 1 characters\",\n      \"type\": \"value_error.any_str.min_length\"\n    }\n  ]\n}\n\n// 401 Unauthorized - No Token\n{\n  \"detail\": \"Not authenticated\"\n}\n\n// 403 Forbidden - Token user_id mismatch\n{\n  \"detail\": \"You can only create tasks for yourself\"\n}\nFastAPI Implementation (SQLModel):\npythonfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlmodel import Session\nfrom datetime import datetime\n\nrouter = APIRouter()\n\n@router.post(\n    \"/api/{user_id}/tasks\",\n    response_model=TaskResponse,\n    status_code=status.HTTP_201_CREATED\n)\nasync def create_task(\n    user_id: str,\n    task_data: TaskCreate,\n    session: Session = Depends(get_session),\n    token_user_id: str = Depends(verify_jwt)\n):\n    \"\"\"\n    Create a new task for authenticated user.\n    \"\"\"\n    # Verify user can only create for themselves\n    if user_id != token_user_id:\n        raise HTTPException(\n            status_code=403,\n            detail=\"You can only create tasks for yourself\"\n        )\n    \n    # Create task using SQLModel\n    task = Task(\n        user_id=user_id,\n        title=task_data.title,\n        description=task_data.description,\n        completed=False,\n        created_at=datetime.utcnow(),\n        updated_at=datetime.utcnow()\n    )\n    \n    session.add(task)\n    session.commit()\n    session.refresh(task)\n    \n    return task\nGET /api/{user_id}/tasks (List Tasks)\nRequest:\nhttpGET /api/user_abc123/tasks\nAuthorization: Bearer eyJhbGc...\nSuccess Response (200 OK):\njson[\n  {\n    \"id\": 1,\n    \"user_id\": \"user_abc123\",\n    \"title\": \"Buy groceries\",\n    \"description\": \"Milk, eggs, bread\",\n    \"completed\": false,\n    \"created_at\": \"2025-01-11T10:30:00Z\",\n    \"updated_at\": \"2025-01-11T10:30:00Z\"\n  },\n  {\n    \"id\": 2,\n    \"user_id\": \"user_abc123\",\n    \"title\": \"Call mom\",\n    \"description\": null,\n    \"completed\": true,\n    \"created_at\": \"2025-01-10T15:00:00Z\",\n    \"updated_at\": \"2025-01-11T09:00:00Z\"\n  }\n]\nFastAPI Implementation (SQLModel):\npythonfrom sqlmodel import select\nfrom typing import List\n\n@router.get(\n    \"/api/{user_id}/tasks\",\n    response_model=List[TaskResponse]\n)\nasync def list_tasks(\n    user_id: str,\n    session: Session = Depends(get_session),\n    token_user_id: str = Depends(verify_jwt)\n):\n    \"\"\"\n    Get all tasks for authenticated user.\n    \"\"\"\n    if user_id != token_user_id:\n        raise HTTPException(403, \"Forbidden\")\n    \n    # SQLModel query\n    statement = select(Task).where(\n        Task.user_id == user_id\n    ).order_by(Task.created_at.desc())\n    \n    tasks = session.exec(statement).all()\n    return tasks\nPUT /api/{user_id}/tasks/{id} (Update Task)\nRequest:\nhttpPUT /api/user_abc123/tasks/5\nAuthorization: Bearer eyJhbGc...\nContent-Type: application/json\n\n{\n  \"title\": \"Buy groceries and fruits\",\n  \"description\": \"Milk, eggs, bread, apples\"\n}\nSuccess Response (200 OK):\njson{\n  \"id\": 5,\n  \"user_id\": \"user_abc123\",\n  \"title\": \"Buy groceries and fruits\",\n  \"description\": \"Milk, eggs, bread, apples\",\n  \"completed\": false,\n  \"created_at\": \"2025-01-11T10:30:00Z\",\n  \"updated_at\": \"2025-01-11T11:00:00Z\"\n}\nFastAPI Implementation (SQLModel):\npython@router.put(\n    \"/api/{user_id}/tasks/{task_id}\",\n    response_model=TaskResponse\n)\nasync def update_task(\n    user_id: str,\n    task_id: int,\n    task_data: TaskUpdate,\n    session: Session = Depends(get_session),\n    token_user_id: str = Depends(verify_jwt)\n):\n    \"\"\"Update task details.\"\"\"\n    if user_id != token_user_id:\n        raise HTTPException(403, \"Forbidden\")\n    \n    # Find task\n    statement = select(Task).where(\n        Task.id == task_id,\n        Task.user_id == user_id\n    )\n    task = session.exec(statement).first()\n    \n    if not task:\n        raise HTTPException(404, \"Task not found\")\n    \n    # Update fields\n    if task_data.title is not None:\n        task.title = task_data.title\n    if task_data.description is not None:\n        task.description = task_data.description\n    \n    task.updated_at = datetime.utcnow()\n    \n    session.add(task)\n    session.commit()\n    session.refresh(task)\n    \n    return task\nDELETE /api/{user_id}/tasks/{id} (Delete Task)\nRequest:\nhttpDELETE /api/user_abc123/tasks/5\nAuthorization: Bearer eyJhbGc...\nSuccess Response (204 No Content):\n(Empty body)\nFastAPI Implementation (SQLModel):\npython@router.delete(\n    \"/api/{user_id}/tasks/{task_id}\",\n    status_code=status.HTTP_204_NO_CONTENT\n)\nasync def delete_task(\n    user_id: str,\n    task_id: int,\n    session: Session = Depends(get_session),\n    token_user_id: str = Depends(verify_jwt)\n):\n    \"\"\"Delete a task.\"\"\"\n    if user_id != token_user_id:\n        raise HTTPException(403, \"Forbidden\")\n    \n    statement = select(Task).where(\n        Task.id == task_id,\n        Task.user_id == user_id\n    )\n    task = session.exec(statement).first()\n    \n    if not task:\n        raise HTTPException(404, \"Task not found\")\n    \n    session.delete(task)\n    session.commit()\n    \n    return None\nPATCH /api/{user_id}/tasks/{id}/complete (Toggle Complete)\nRequest:\nhttpPATCH /api/user_abc123/tasks/5/complete\nAuthorization: Bearer eyJhbGc...\nSuccess Response (200 OK):\njson{\n  \"id\": 5,\n  \"user_id\": \"user_abc123\",\n  \"title\": \"Buy groceries\",\n  \"description\": \"Milk, eggs, bread\",\n  \"completed\": true,\n  \"created_at\": \"2025-01-11T10:30:00Z\",\n  \"updated_at\": \"2025-01-11T11:15:00Z\"\n}\nFastAPI Implementation (SQLModel):\npython@router.patch(\n    \"/api/{user_id}/tasks/{task_id}/complete\",\n    response_model=TaskResponse\n)\nasync def toggle_complete(\n    user_id: str,\n    task_id: int,\n    session: Session = Depends(get_session),\n    token_user_id: str = Depends(verify_jwt)\n):\n    \"\"\"Toggle task completion status.\"\"\"\n    if user_id != token_user_id:\n        raise HTTPException(403, \"Forbidden\")\n    \n    statement = select(Task).where(\n        Task.id == task_id,\n        Task.user_id == user_id\n    )\n    task = session.exec(statement).first()\n    \n    if not task:\n        raise HTTPException(404, \"Task not found\")\n    \n    # Toggle completed\n    task.completed = not task.completed\n    task.updated_at = datetime.utcnow()\n    \n    session.add(task)\n    session.commit()\n    session.refresh(task)\n    \n    return task\n6.5 Error Response Format\nAll errors follow FastAPI's standard format:\njson{\n  \"detail\": \"Error message here\"\n}\nStatus Codes:\n\n200 OK - Success (GET, PUT, PATCH)\n201 Created - Resource created (POST)\n204 No Content - Success, no body (DELETE)\n400 Bad Request - Validation error\n401 Unauthorized - Missing/invalid token\n403 Forbidden - Insufficient permissions\n404 Not Found - Resource doesn't exist\n500 Internal Server Error - Server error\n\n\n7. Authentication & Security\n7.1 Better Auth Setup\nFrontend Configuration (Next.js)\ntypescript// lib/auth.ts\nimport { betterAuth } from \"better-auth/client\"\n\nexport const auth = betterAuth({\n  baseURL: process.env.NEXT_PUBLIC_API_URL,\n  credentials: \"include\",\n  plugins: [\n    // Enable JWT plugin\n    {\n      id: \"jwt\",\n      endpoints: {\n        getToken: \"/api/auth/token\"\n      }\n    }\n  ]\n})\nEnvironment Variables\nbash# Frontend (.env.local)\nNEXT_PUBLIC_API_URL=http://localhost:8000\nBETTER_AUTH_SECRET=your-super-secret-key-min-32-chars\n\n# Backend (.env)\nDATABASE_URL=postgresql://...\nBETTER_AUTH_SECRET=your-super-secret-key-min-32-chars  # MUST MATCH\nCORS_ORIGIN=http://localhost:3000\n7.2 JWT Verification (Backend)\nMiddleware Implementation\npythonfrom fastapi import Depends, HTTPException, Header\nfrom jose import JWTError, jwt\nimport os\n\nSECRET_KEY = os.getenv(\"BETTER_AUTH_SECRET\")\nALGORITHM = \"HS256\"\n\nasync def verify_jwt(authorization: str = Header(...)):\n    \"\"\"\n    Verify JWT token from Authorization header.\n    Returns user_id from token claims.\n    \"\"\"\n    try:\n        # Extract token from \"Bearer <token>\"\n        scheme, token = authorization.split()\n        if scheme.lower() != \"bearer\":\n            raise HTTPException(401, \"Invalid authentication scheme\")\n        \n        # Verify and decode JWT\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        \n        # Extract user_id from claims\n        user_id: str = payload.get(\"sub\")\n        if not user_id:\n            raise HTTPException(401, \"Invalid token claims\")\n        \n        return user_id\n        \n    except (JWTError, ValueError):\n        raise HTTPException(401, \"Could not validate credentials\")\n7.3 CORS Configuration\npythonfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nimport os\n\napp = FastAPI()\n\n# Configure CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[os.getenv(\"CORS_ORIGIN\", \"http://localhost:3000\")],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n8. Frontend Specification\n8.1 Project Structure\nfrontend/\n├── app/\n│   ├── layout.tsx          # Root layout\n│   ├── page.tsx            # Home page (redirect to signin)\n│   ├── signin/\n│   │   └── page.tsx        # Signin page\n│   ├── signup/\n│   │   └── page.tsx        # Signup page\n│   └── tasks/\n│       └── page.tsx        # Task list page (protected)\n├── components/\n│   ├── TaskList.tsx        # Task list component\n│   ├── TaskItem.tsx        # Single task card\n│   ├── TaskForm.tsx        # Add/Edit task form\n│   └── AuthForm.tsx        # Reusable auth form\n├── lib/\n│   ├── api.ts              # API client wrapper\n│   ├── auth.ts             # Better Auth config\n│   └── types.ts            # TypeScript types\n└── package.json\n8.2 API Client (Frontend)\ntypescript// lib/api.ts\nimport { auth } from './auth'\n\nconst API_BASE = process.env.NEXT_PUBLIC_API_URL\n\nexport const api = {\n  // Get all tasks\n  async getTasks(userId: string) {\n    const token = await auth.getToken()\n    const response = await fetch(`${API_BASE}/api/${userId}/tasks`, {\n      headers: {\n        'Authorization': `Bearer ${token}`\n      }\n    })\n    if (!response.ok) throw new Error('Failed to fetch tasks')\n    return response.json()\n  },\n\n  // Create task\n  async createTask(userId: string, data: { title: string, description?: string }) {\n    const token = await auth.getToken()\n    const response = await fetch(`${API_BASE}/api/${userId}/tasks`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    })\n    if (!response.ok) throw new Error('Failed to create task')\n    return response.json()\n  },\n\n  // Update task\n  async updateTask(userId: string, taskId: number, data: Partial<{ title: string, description: string }>) {\n    const token = await auth.getToken()\n    const response = await fetch(`${API_BASE}/api/${userId}/tasks/${taskId}`, {\n      method: 'PUT',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    })\n    if (!response.ok) throw new Error('Failed to update task')\n    return response.json()\n  },\n\n  // Delete task\n  async deleteTask(userId: string, taskId: number) {\n    const token = await auth.getToken()\n    const response = await fetch(`${API_BASE}/api/${userId}/tasks/${taskId}`, {\n      method: 'DELETE',\n      headers: {\n        'Authorization': `Bearer ${token}`\n      }\n    })\n    if (!response.ok) throw new Error('Failed to delete task')\n  },\n\n  // Toggle complete\n  async toggleComplete(userId: string, taskId: number) {\n    const token = await auth.getToken()\n    const response = await fetch(`${API_BASE}/api/${userId}/tasks/${taskId}/complete`, {\n      method: 'PATCH',\n      headers: {\n        'Authorization': `Bearer ${token}`\n      }\n    })\n    if (!response.ok) throw new Error('Failed to toggle task')\n    return response.json()\n  }\n}\n8.3 Task List Component\ntypescript// components/TaskList.tsx\n'use client'\n\nimport { useState, useEffect } from 'react'\nimport { api } from '@/lib/api'\nimport TaskItem from './TaskItem'\nimport TaskForm from './TaskForm'\n\ninterface Task {\n  id: number\n  title: string\n  description?: string\n  completed: boolean\n  created_at: string\n}\n\nexport default function TaskList({ userId }: { userId: string }) {\n  const [tasks, setTasks] = useState<Task[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState('')\n  const [showForm, setShowForm] = useState(false)\n\n  // Fetch tasks on mount\n  useEffect(() => {\n    loadTasks()\n  }, [])\n\n  async function loadTasks() {\n    try {\n      setLoading(true)\n      const data = await api.getTasks(userId)\n      setTasks(data)\n    } catch (err) {\n      setError('Failed to load tasks')\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  async function handleCreate(data: { title: string, description?: string }) {\n    try {\n      const newTask = await api.createTask(userId, data)\n      setTasks([newTask, ...tasks])\n      setShowForm(false)\n    } catch (err) {\n      setError('Failed to create task')\n    }\n  }\n\n  async function handleToggle(taskId: number) {\n    try {\n      const updated = await api.toggleComplete(userId, taskId)\n      setTasks(tasks.map(t => t.id === taskId ? updated : t))\n    } catch (err) {\n      setError('Failed to update task')\n    }\n  }\n\n  async function handleDelete(taskId: number) {\n    if (!confirm('Delete this task?')) return\n    \n    try {\n      await api.deleteTask(userId, taskId)\n      setTasks(tasks.filter(t => t.id !== taskId))\n    } catch (err) {\n      setError('Failed to delete task')\n    }\n  }\n\n  if (loading) return <div>Loading...</div>\n  if (error) return <div className=\"text-red-500\">{error}</div>\n\n  return (\n    <div className=\"max-w-2xl mx-auto p-4\">\n      <div className=\"flex justify-between items-center mb-6\">\n        <h1 className=\"text-2xl font-bold\">My Tasks</h1>\n        <button\n          onClick={() => setShowForm(true)}\n          className=\"bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600\"\n        >\n          + Add Task\n        </button>\n      </div>\n\n      {showForm && (\n        <TaskForm\n          onSubmit={handleCreate}\n          onCancel={() => setShowForm(false)}\n        />\n      )}\n\n      {tasks.length === 0 ? (\n        <p className=\"text-gray-500 text-center py-8\">\n          No tasks yet. Create one to get started!\n        </p>\n      ) : (\n        <div className=\"space-y-3\">\n          {tasks.map(task => (\n            <TaskItem\n              key={task.id}\n              task={task}\n              onToggle={handleToggle}\n              onDelete={handleDelete}\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  )\n}\n8.4 UI Color Scheme & Typography\nColors:\n\nPrimary: #3B82F6 (blue-500)\nSuccess: #10B981 (green-500)\nDanger: #EF4444 (red-500)\nBackground: #FFFFFF (white)\nText: #111827 (gray-900)\nBorder: #D1D5DB (gray-300)\n\nTypography:\n\nFont: Inter, system-ui, sans-serif\nBase size: 16px\nHeadings: font-bold\nBody: font-normal\n\n\n9. Implementation Plan\n9.1 Phase 2 Sub-Phases\nPhase 2.1: Backend Foundation (Day 1-2)\nGoal: Set up backend with database\nTasks:\n\nCreate phase-2-fullstack/backend/ directory\nInitialize Python project: uv init\nInstall dependencies: fastapi, sqlmodel, uvicorn, python-jose\nCreate Neon database and get connection string\nSet up environment variables\nWrite SQLModel Task and User models\nCreate database connection module\nRun migrations (create tables)\nTest connection with simple query\n\nDeliverables:\n\n✅ Backend folder structure\n✅ SQLModel models defined\n✅ Database tables created in Neon\n✅ Connection working\n\nPhase 2.2: API Development (Day 3-4)\nGoal: Build all REST endpoints\nTasks:\n\nCreate FastAPI app instance\nConfigure CORS middleware\nImplement JWT verification middleware\nCreate task routes:\n\nPOST /api/{user_id}/tasks\nGET /api/{user_id}/tasks\nPUT /api/{user_id}/tasks/{id}\nDELETE /api/{user_id}/tasks/{id}\nPATCH /api/{user_id}/tasks/{id}/complete\n\n\nAdd error handling\nTest each endpoint with curl/Postman\nDocument API with FastAPI auto-docs\n\nDeliverables:\n\n✅ All CRUD endpoints working\n✅ JWT auth enforced\n✅ User isolation verified\n✅ API docs accessible at /docs\n\nPhase 2.3: Frontend Foundation (Day 5-6)\nGoal: Set up Next.js with authentication\nTasks:\n\nCreate phase-2-fullstack/frontend/ directory\nInitialize Next.js: npx create-next-app@latest\nInstall Better Auth\nConfigure Better Auth with JWT plugin\nCreate API client wrapper (lib/api.ts)\nBuild authentication pages:\n\nSignup page\nSignin page\n\n\nImplement protected route logic\nTest auth flow end-to-end\n\nDeliverables:\n\n✅ Next.js app running\n✅ Better Auth configured\n✅ Users can signup/signin\n✅ JWT tokens working\n\nPhase 2.4: Task UI (Day 7-8)\nGoal: Build task management interface\nTasks:\n\nCreate TaskList component\nCreate TaskItem component (single task card)\nCreate TaskForm component (add/edit modal)\nImplement CRUD operations:\n\nDisplay task list\nAdd new task\nEdit task\nDelete task (with confirmation)\nToggle completion\n\n\nAdd loading states\nAdd error handling\nMake responsive (mobile + desktop)\n\nDeliverables:\n\n✅ Full task UI working\n✅ All operations functional\n✅ Responsive design\n✅ Good UX (loading, errors)\n\nPhase 2.5: Integration & Polish (Day 9-10)\nGoal: Connect frontend to backend, refine UX\nTasks:\n\nConnect frontend API calls to backend\nTest full E2E flow:\n\nSignup → Signin → Add task → Update → Delete\n\n\nVerify user isolation (create test users)\nAdd success messages/toasts\nImprove error messages\nPolish UI styling\nFix any bugs\nAdd logout functionality\n\nDeliverables:\n\n✅ Full integration working\n✅ No data leakage between users\n✅ Smooth UX\n✅ Production-ready\n\nPhase 2.6: Deployment (Day 11-12)\nGoal: Deploy to production\nTasks:\n\nDeploy backend:\n\nRailway/Render/Fly.io\nSet environment variables\nTest API endpoint\n\n\nDeploy frontend:\n\nVercel\nSet environment variables\nPoint to production backend\n\n\nVerify production deployment\nRecord demo video (90 seconds)\nUpdate README with:\n\nSetup instructions\nEnvironment variables\nDeployment links\n\n\nSubmit via Google Form\n\nDeliverables:\n\n✅ Backend deployed and accessible\n✅ Frontend deployed on Vercel\n✅ Demo video recorded\n✅ README complete\n✅ Submitted to hackathon\n\n\n10. Testing Strategy\n10.1 Backend Testing\nUnit Tests (SQLModel)\npython# tests/test_database.py\nimport pytest\nfrom sqlmodel import Session, create_engine, SQLModel\nfrom sqlalchemy.pool import StaticPool\n\n@pytest.fixture\ndef session():\n    engine = create_engine(\n        \"sqlite:///:memory:\",\n        connect_args={\"check_same_thread\": False},\n        poolclass=StaticPool,\n    )\n    SQLModel.metadata.create_all(engine)\n    \n    with Session(engine) as session:\n        yield session\ndef test_create_task(session):\n    task = Task(\n        user_id=\"test_user\",\n        title=\"Test Task\",\n        description=\"Test Description\"\n    )\n    session.add(task)\n    session.commit()\n    session.refresh(task)\n    \n    assert task.id is not None\n    assert task.title == \"Test Task\"\n    assert task.completed is False\ndef test_user_isolation(session):\n    # User 1 task\n    task1 = Task(user_id=\"user1\", title=\"User 1 Task\")\n    # User 2 task\n    task2 = Task(user_id=\"user2\", title=\"User 2 Task\")\n    \n    session.add_all([task1, task2])\n    session.commit()\n    \n    # Query user 1 tasks\n    from sqlmodel import select\n    statement = select(Task).where(Task.user_id == \"user1\")\n    user1_tasks = session.exec(statement).all()\n    \n    assert len(user1_tasks) == 1\n    assert user1_tasks[0].title == \"User 1 Task\"\nAPI Tests\npython# tests/test_api.py\nfrom fastapi.testclient import TestClient\nfrom main import app\n\nclient = TestClient(app)\n\ndef test_create_task_success():\n    # Mock JWT token\n    headers = {\"Authorization\": \"Bearer mock_token\"}\n    \n    response = client.post(\n        \"/api/user123/tasks\",\n        headers=headers,\n        json={\"title\": \"Test Task\"}\n    )\n    \n    assert response.status_code == 201\n    assert response.json()[\"title\"] == \"Test Task\"\ndef test_create_task_unauthorized():\n    response = client.post(\n        \"/api/user123/tasks\",\n        json={\"title\": \"Test Task\"}\n    )\n    \n    assert response.status_code == 401\n10.2 Manual Testing Checklist\nAuthentication Flow\n\n User can signup with valid email/password\n Duplicate email shows error\n User can signin with correct credentials\n Invalid credentials show error\n JWT token stored correctly\n Protected routes redirect if not logged in\n\nTask Operations\n\n User can create task with title only\n User can create task with title + description\n Empty title shows validation error\n User can view all their tasks\n Tasks sorted by newest first\n User can edit task title\n User can edit task description\n User can delete task (with confirmation)\n User can mark task complete\n Completed task shows strikethrough\n User can toggle back to incomplete\n\nUser Isolation\n\n Create two test accounts\n Login as user1, create tasks\n Login as user2, verify can't see user1's tasks\n Try accessing user1's task with user2's token (should fail)\n\nEdge Cases\n\n Title with 200 characters (should work)\n Title with 201 characters (should fail)\n Description with 1000 characters (should work)\n Special characters in title/description\n Network error handling (disconnect wifi)\n Slow network (throttle connection)\n\nResponsive Design\n\n Test on iPhone SE (375px)\n Test on iPad (768px)\n Test on desktop (1920px)\n All buttons accessible\n Forms usable on mobile\n No horizontal scroll\n\n\n11. Deployment Guide\n11.1 Database (Neon)\nSteps:\n\nGo to https://neon.tech\nSign up (GitHub recommended)\nCreate new project\nCopy connection string\nRun migration SQL in SQL Editor\nVerify tables created\n\nConnection String Format:\npostgresql://username:password@ep-xxx-xxx.region.aws.neon.tech/neondb?sslmode=require\n11.2 Backend Deployment (Railway)\nSteps:\n\nGo to https://railway.app\nNew Project → Deploy from GitHub repo\nSelect phase-2-fullstack/backend directory\nAdd environment variables:\n\n   DATABASE_URL=postgresql://...\n   BETTER_AUTH_SECRET=your-secret-key\n   CORS_ORIGIN=https://your-frontend.vercel.app\n\nDeploy\nCopy generated URL (e.g., https://backend.railway.app)\nTest: curl https://backend.railway.app/docs\n\nAlternative: Render.com\n\nFree tier available\nSimilar process\nSlower cold starts\n\n11.3 Frontend Deployment (Vercel)\nSteps:\n\nGo to https://vercel.com\nImport Git Repository\nFramework: Next.js (auto-detected)\nRoot Directory: phase-2-fullstack/frontend\nAdd environment variables:\n\n   NEXT_PUBLIC_API_URL=https://backend.railway.app\n   BETTER_AUTH_SECRET=your-secret-key\n\nDeploy\nGet URL (e.g., https://todo-app.vercel.app)\n\n11.4 Post-Deployment Verification\nChecklist:\n\n Backend /docs accessible\n Frontend homepage loads\n Can signup new user\n Can signin\n Can create task\n Can view tasks\n Can update task\n Can delete task\n Can toggle complete\n No CORS errors in browser console\n\n\n12. Quality Gates\n12.1 Before Submission Checklist\nCode Quality\n\n All code generated via Claude Code (spec-driven)\n SQLModel used (not raw SQLAlchemy)\n Type hints on all Python functions\n TypeScript strict mode enabled\n No any types in frontend\n Environment variables for all secrets\n No hardcoded URLs or credentials\n\nFunctionality\n\n All 5 basic features working\n User signup/signin working\n JWT authentication enforced\n User isolation verified\n All CRUD operations functional\n Error handling on all endpoints\n Loading states in UI\n Success feedback for actions\n\nDocumentation\n\n README.md with setup instructions\n Environment variables documented\n API endpoints documented\n Database schema documented\n Deployment links included\n\nDeployment\n\n Backen"
response_text: "Successfully created the specification for the Phase 2 Full-Stack Todo Web Application. The specification includes user scenarios, functional requirements, success criteria, and follows the template structure. The spec file was created at specs/004-full-stack-todo-phase-2/spec.md with a corresponding quality checklist at specs/004-full-stack-todo-phase-2/checklists/requirements.md."
outcome: "Specification created successfully for Phase 2 full-stack todo application"
evaluation: "Specification meets all requirements with clear user stories, functional requirements, and measurable success criteria"
---

# Create Phase 2 Spec

## Summary
Created a comprehensive specification for the Phase 2 Full-Stack Todo Web Application based on the detailed requirements provided by the user.

## Details
The user requested creation of a specification for transforming the Phase 1 console todo app into a modern, multi-user web application with persistent storage, authentication, and RESTful API architecture. I created a complete specification document with user stories, functional requirements, and success criteria.

## Changes Made
- Created spec file at specs/004-full-stack-todo-phase-2/spec.md
- Created quality checklist at specs/004-full-stack-todo-phase-2/checklists/requirements.md
- Included user stories for core functionality (task management, authentication, security)
- Defined functional requirements and success criteria
- Validated all requirements follow the template structure